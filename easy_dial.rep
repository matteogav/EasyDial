struct node_tst{
  node_tst* _esq;
  node_tst* _central;
  node_tst* _dret;
	node_tst* _pare;
  nat nivell;
  char _lletra;           //guarda la lletra que tracta
  nat _tlf;
  string maxFr;
  string antFr;
};

node_tst* _arrel;
nat total_freq;           //denominador
nat numerador;            //numerador
nat _tlf_arrel;
node_tst* _pref_n;
bool _pref_indef;
bool null_pref_n;         //indicar que el pref_n hauria anat a NULL
bool es_buit;             //indicar que el seguent ha donat string buida
string _prefix;

void insereix(const phone& P, bool &arr) throw();
node_tst* rinsereix(node_tst* n, nat &i, string s, string &nom, const nat &telef, bool &arrel, string ant_ant, node_tst* res, const nat &freq, nat &puls_num) throw(error);
static void esborra_tst(node_tst* n) throw();
static node_tst* copia_tst(node_tst* n) throw(error);
static void emplena_v(node_tst* n, vector<string>& result, const string& pref, nat& i, string &aux) throw();
static void ordena(vector<phone> &v, int n) throw();
static void partir(vector<phone> &v, vector<phone> &v2, int m) throw();
static void fusionar(vector<phone> &v, vector<phone> &v2) throw();

/*
Aquesta classe l'hem implementat fent ús de la memòria dinàmica. Concretament hem utilitzat una estructura
d'arbre ternari de cerca, TST. Com que seguent(char), anterior() i num_tlef() necessitaven ser cost constant
hem escollit la millor estructura quant a costos per poder fer aquestes 3 funcions. En tenir-ho ordenat per
lletres de més petita a més gran el cost de la cerca de la següent o anterior lletra és, en el pitjor dels casos,
de 24 moviments esquerra o dreta.

insereix(const phone& P, bool &arr):
Aquesta funció el que fa és: Rep un booleà que indica si és l'arrel del TST o no, i rep també
objecte del tipus phone, descomposa la informació que conté aquest objecte, per exemple, el telefon,
el nom amb el caracter '\0' afegit, etc. Per així fer la crida al metode rinserix, que l'insereix al arbre.

rinsereix(node_tst* n, nat &i, string s, string &nom, const nat &telef, bool &arrel, string ant_ant, node_tst* res, const nat &freq, nat &puls_num):
Aquesta funció el que fa és: Si el node n no existeix a l'arbre l'afegeix amb la lletra i els seus
altres camps corresponents, si ja exisitia segueix recorrent.

esborra_tst(node_tst* n):
Aquesta funció el que fa és: Esborra de manera recursiva el TST, a partir del node donat.

copia_tst(node_tst* n):
Aquesta funció el que fa és: Copia de manera recursiva el TST, a partir del node donat.

emplena_v(node_tst* n, vector<string>& result, const string& pref, nat& i, string &aux):
Aquesta funció el que fa és: Primer buscar per tot el TST el prefix pref, un cop hem trobat el prefix a
partir d'allà buscar tots els noms que hi puguin haver amb el recorregut en preordre, així els obtenim per
ordre alfabètic. Quan arriba a fi de nom \0 mira si hi ha un fill dret i continuar i/o torna enrere.

ordena(vector<phone> &v, int n):
Aquesta funció el que fa és: Fa el mètode d'ordenació Mergesort

partir(vector<phone> &v, vector<phone> &v2, int m):
Aquesta funció el que fa és: Parteix en el mètode d'ordenació Mergesort

fusionar(vector<phone> &v, vector<phone> &v2):
Aquesta funció el que fa és: Fusiona en el mètode d'ordenació Mergesort

*/
